// Schema validation utilities
import { SchemaField, ValidationError } from './types';

export function validateAgainstSchema(
  data: Record<string, any>,
  schema: SchemaField[]
): { valid: boolean; errors: ValidationError[] } {
  const errors: ValidationError[] = [];

  // Check required fields (except auto-generated ones like eventId)
  const autoGeneratedFields = ['eventid', 'event_id', 'memoryrecordid', 'memory_record_id', 'createdat', 'created_at'];

  for (const field of schema) {
    const isAutoGenerated = autoGeneratedFields.includes(field.name.toLowerCase());
    if (field.required && !isAutoGenerated && !(field.name in data)) {
      errors.push({
        field: field.name,
        message: `Missing required field: ${field.name}`,
        expected: field.type,
      });
    }
  }

  // Check field types for known fields only (allow extra fields)
  for (const [key, value] of Object.entries(data)) {
    const fieldSchema = schema.find((f) => f.name === key);

    // Skip validation for unknown fields - be lenient
    if (!fieldSchema) {
      continue;
    }

    // Skip type check for null/undefined on non-required fields
    if ((value === null || value === undefined) && !fieldSchema.required) {
      continue;
    }

    const actualType = getValueType(value);
    if (actualType !== fieldSchema.type) {
      errors.push({
        field: key,
        message: `Type mismatch for field: ${key}`,
        expected: fieldSchema.type,
        received: actualType,
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

function getValueType(value: any): string {
  if (value === null || value === undefined) {
    return 'undefined';
  }
  if (Array.isArray(value)) {
    return 'array';
  }
  if (typeof value === 'object') {
    return 'object';
  }
  return typeof value;
}

export function createValidationErrorResponse(errors: ValidationError[]) {
  return {
    success: false,
    error: 'Validation failed',
    errors,
  };
}

